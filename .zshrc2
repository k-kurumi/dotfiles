export EDITOR=vim

# pecoでコマンド履歴検索
function peco_select_history() {
  local tac
  if which tac > /dev/null; then
    tac="tac"
  else
    tac="tail -r"
  fi

  BUFFER=$(\history -n 1 | \
    eval $tac | \
    peco --query "$LBUFFER")
  CURSOR=$#BUFFER
  zle clear-screen
}
zle -N peco_select_history
bindkey '^R' peco_select_history

# ruby
export PATH="$HOME/.rbenv/bin:$PATH"
export PATH="$HOME/.rbenv/shims:$PATH"  # /usr/local/bin/rubyが先に読まれるため上書きする

# python
export PYENV_ROOT="$HOME/.pyenv"
export PATH="$PYENV_ROOT/bin:$PATH"
eval "$(pyenv init -)"

# node
export PATH="$HOME/.ndenv/bin:$PATH"
eval "$(ndenv init -)"

# golang(1.8のデフォルトとは違う)
export GOPATH=${HOME}/dev
export GOROOT=${HOME}/go
export PATH=${GOPATH}/bin:${PATH}
export PATH=${GOROOT}/bin:${PATH}

# rust
export RUST_SRC_PATH=${HOME}/.multirust/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/src

# direnv
eval "$(direnv hook zsh)"

# プロンプトまわりの設定(pureで)
# autoload -Uz colors
# colors
# autoload -Uz vcs_info
# setopt prompt_subst
# zstyle ':vcs_info:git:*' check-for-changes true #formats 設定項目で %c,%u が使用可
# zstyle ':vcs_info:git:*' stagedstr "%F{green}!" #commit されていないファイルがある
# zstyle ':vcs_info:git:*' unstagedstr "%F{magenta}+" #add されていないファイルがある
# zstyle ':vcs_info:*' formats "%F{cyan}%c%u(%b)%f" #通常
# zstyle ':vcs_info:*' actionformats '[%b|%a]' #rebase 途中,merge コンフリクト等 formats 外の表示
# precmd() { vcs_info }
# PROMPT='
# %{$fg[black]%(?.$bg[green].$bg[red])%} %? %{$reset_color%} %{$fg[green]%}>>>%{${reset_color}%} ${vcs_info_msg_0_} %{$fg[yellow]%}%~%{${reset_color}%}
# $ '
# RPROMPT=''

# 自作より軽快に動作する気がする
# 機能も十分なのでしばらく使ってみる
# https://github.com/sindresorhus/pure
PURE_PROMPT_SYMBOL=$
prompt pure

# ^を展開しないようにするためgitでHEAD^などがエスケープなしで使えるようになる
unsetopt extended_glob

# history
HISTFILE=~/.zhistory
HISTSIZE=100000
SAVEHIST=100000
setopt hist_ignore_dups     # ignore duplication command history list
setopt share_history        # share command history data

# cf a のソート
cfa() {
  LANG=en_US.UTF-8 CF_TRACE=false CF_COLOR=false cf a | awk 'BEGIN{idx=0;} (NR <= 4){print} (NR > 4){buf[idx++]=$0} END{asort(buf);for(i=1;i<=idx;i++){print buf[i]}}'
}

# cf s のソート
cfs() {
  LANG=en_US.UTF-8 CF_TRACE=false CF_COLOR=false cf s | awk 'BEGIN{idx=0;} (NR <= 4){print} (NR > 4){buf[idx++]=$0} END{asort(buf);for(i=1;i<=idx;i++){print buf[i]}}'
}

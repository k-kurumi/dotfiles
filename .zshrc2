# zprezto経由でpureを使う
prompt pure

export EDITOR=vim
export VISUAL=vim # macのcrontab用
export LANGUAGE=en
export LANG=en_US.UTF-8

# echo -n aaa など改行がない状態でも表示できるようにする
# デフォルトで表示する設定になったため不要になった
# pureはv1.7.0は表示不可(手動でsubmoduleをv1.8.0に切り替えると表示可能)
# unsetopt promptcr

# fzfとコマンドサンプル
# https://github.com/junegunn/fzf/wiki/examples
# fe [FUZZY PATTERN] - Open the selected file with the default editor
#   - Bypass fuzzy finder if there's only one match (--select-1)
#   - Exit if there's no match (--exit-0)
fe() {
  local files
  IFS=$'\n' files=($(fzf-tmux --query="$1" --multi --select-1 --exit-0))
  [[ -n "$files" ]] && ${EDITOR:-vim} "${files[@]}"
}
# fd - cd to selected directory
fd() {
  local dir
  dir=$(find ${1:-.} -path '*/\.*' -prune \
                  -o -type d -print 2> /dev/null | fzf +m) &&
  cd "$dir"
}

# カレントから選択してvimで開く
vimf() {
  local text
  text=$(find . -type f -and -not -path './.git/*' | fzf --select-1 --exit-0)
  vim ${text}
}

# fzfでhistory表示
function fzf_select_history() {
  BUFFER=$(history -n 1 | fzf)
  zle clear-screen
}
zle -N fzf_select_history
bindkey '^R' fzf_select_history

# fzfでghqリポジトリに移動する
function fzf_select_ghq_repo() {
  local selected_dir=$(ghq list -p | fzf --multi --select-1 --exit-0)
  echo $selected_dir
  if [ -n "$selected_dir" ]; then
    BUFFER="cd ${selected_dir}"
    zle accept-line
  fi
  zle clear-screen
}
zle -N fzf_select_ghq_repo
bindkey '^G' fzf_select_ghq_repo

# ruby
if [[ -d ~/.rbenv ]]; then
  export PATH="$HOME/.rbenv/bin:$PATH"
  export PATH="$HOME/.rbenv/shims:$PATH"  # /usr/local/bin/rubyが先に読まれるため上書きする
fi

# python
if [[ -d ~/.pyenv ]]; then
  export PYENV_ROOT="$HOME/.pyenv"
  export PATH="$PYENV_ROOT/bin:$PATH"
  eval "$(pyenv init -)"
fi

# node
if [[ -d ~/.ndenv ]]; then
  export PATH="$HOME/.ndenv/bin:$PATH"
  eval "$(ndenv init -)"
fi

# golang(1.8のデフォルトとは違う)
export GOPATH=${HOME}/dev
export GOROOT=${HOME}/go
export PATH=${GOPATH}/bin:${PATH}
export PATH=${GOROOT}/bin:${PATH}

# rust
export RUST_SRC_PATH=${HOME}/.multirust/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/src

# # nim
# mkdir -p ~/.nim/bin # macはbrewで入れるためダミーとして作っておく
# export NIM_HOME=~/.nim
# export PATH=${NIM_HOME}/bin:$PATH

# direnv
if type direnv > /dev/null; then
  eval "$(direnv hook zsh)"
fi

# ^を展開しないようにするためgitでHEAD^などがエスケープなしで使えるようになる
unsetopt extended_glob

# history
HISTFILE=~/.zsh_history
HISTSIZE=100000
SAVEHIST=100000
setopt hist_ignore_dups     # ignore duplication command history list
setopt share_history        # share command history data

# https://github.com/sindresorhus/pure
export PURE_PROMPT_SYMBOL=$

# cf a のソート
cfa() {
  LANG=en_US.UTF-8 CF_TRACE=false CF_COLOR=false cf a | awk 'BEGIN{idx=0;} (NR <= 4){print} (NR > 4){buf[idx++]=$0} END{asort(buf);for(i=1;i<=idx;i++){print buf[i]}}'
}

# cf s のソート
cfs() {
  LANG=en_US.UTF-8 CF_TRACE=false CF_COLOR=false cf s | awk 'BEGIN{idx=0;} (NR <= 4){print} (NR > 4){buf[idx++]=$0} END{asort(buf);for(i=1;i<=idx;i++){print buf[i]}}'
}

# json to yaml
j2y() {
  ruby -ryaml -rjson -e 'puts YAML.dump(JSON.load(ARGF.read))'
}

# yaml to json
y2j() {
  ruby -ryaml -rjson -e 'puts JSON.pretty_generate(YAML.load(ARGF.read))'
}

# python版
py2j() {
  python -c 'import sys,yaml,json; print json.dumps(yaml.load(sys.stdin, Loader=yaml.SafeLoader), indent=2)'
}
pj2y() {
  python -c 'import sys,yaml,json; print yaml.safe_dump(json.load(sys.stdin))'
}

# tigよりわかりやすいgitツリー
function gitt() { git-foresta --style=10 "$@" | less -RSX }
function gitta() { git-foresta --all --style=10 "$@" | less -RSX }
compdef _git gitt=git-log
compdef _git gitta=git-log

# mkdir-p風にフォルダを作ってからtouchする
function touch_p() {
  for item in $@
  do
    echo "touch: ${item}"
    mkdir -p $(dirname ${item})
    touch ${item}
  done
}

# $ echo abc_def | camel
# AbcDef
function camel() {
  perl -pe 's#(_|^)(.)#\u$2#g'
}

# $ echo AbcDef | snake
# abc_def
function snake() {
  perl -pe 's#([A-Z])#_\L$1#g' | perl -pe 's#^_##'
}

# tmuxとguakeのリネーム
function t() {
  # 引数なしはカレントフォルダ名にする
  local name=${1:-$(basename $PWD)}
  type guake > /dev/null && guake -r "${name}"
  type tmux  > /dev/null && tmux rename-session "${name}"
}

# clipper経由でクリップボードにコピー
# usage:) ls -l | clip
alias clip='nc localhost 8377'

# 鍵のエージェント
alias ssh_agent_start='eval `ssh-agent` && ssh-add ~/.ssh/id_rsa'

if [[ x$(uname) = xLinux ]]; then
  # Xが起動しているときpbcopy風のalias
  # sshで入っていると$DISPLAYは空になる
  if [[ $DISPLAY ]]; then
    # https://linuxfan.info/xclip
    alias pbcopy='xclip -selection c'
    alias pbpaste='xclip -selection c -o'
  fi
fi

# クエリとファイルパスの順に気をつける
# curl -s 'https://www.google.com/' | xpath '//head/title' -
alias xpath="xmllint --html --xpath 2>/dev/null"

# -v: 自然な並び順
# 標準の ll='ls -lh' では 頭の_が考慮されない
alias ll='ls -lv'

# 指定したファイルをクリップボードに取り込む
function c() {
  # 引数なしは何もしない
  [[ $# -eq 0 ]] && return
  type xsel > /dev/null && cat "${1}" | xsel -bi
}

# dockerhubのタグリストの表示(webだとページングされて見づらいため)
function dockerhub_tag_search {
  # 引数なしは何もしない
  if [[ $# -eq 0 ]]; then
    >&2 echo "usage: $0 <dockerhub-repo-name>"
    return 1
  fi

  local repo=${1}
  curl -s https://registry.hub.docker.com/v1/repositories/${repo}/tags | jq -r '.[]| .name' | fzf
}

source ~/.rdb.sh
source ~/.tool.sh
